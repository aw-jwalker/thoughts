#!/bin/bash
# thoughts init - Initialize thoughts symlinks for a project
#
# Usage: thoughts init [project-name]
#   If project-name is not provided, uses the current directory name
#
# This creates:
# - thoughts/{user}/ -> symlink to user-specific thoughts
# - thoughts/shared/ -> symlink to shared team thoughts
# - thoughts/global/ -> symlink to cross-repo global thoughts
# - thoughts/CLAUDE.md -> instructions for AI tools
# - Git hooks for protection and auto-sync

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/common.sh"

# Hook version for updates
HOOK_VERSION="1"

# Generate CLAUDE.md content
generate_claude_md() {
    local thoughts_repo="$1"
    local repos_dir="$2"
    local repo_name="$3"
    local user="$4"

    cat << EOF
# Thoughts Directory Structure

This directory contains developer thoughts and notes for the ${repo_name} repository.
It is managed by the thoughts CLI and should not be committed to the code repository.

## Structure

- \`${user}/\` -> Your personal notes for this repository
- \`shared/\` -> Team-shared notes for this repository
- \`global/\` -> Cross-repository thoughts
  - \`${user}/\` - Your personal notes that apply across all repositories
  - \`shared/\` - Team-shared notes that apply across all repositories
- \`searchable/\` -> Hard links for searching (auto-generated by \`thoughts sync\`)

## Searching in Thoughts

The \`searchable/\` directory contains hard links to all thoughts files accessible in this repository.
This allows search tools (including AI assistants) to find content without following symlinks.

**IMPORTANT**:
- Files in \`thoughts/searchable/\` are hard links to the original files (editing either updates both)
- For clarity and consistency, always reference files by their canonical path (e.g., \`thoughts/${user}/todo.md\`, not \`thoughts/searchable/${user}/todo.md\`)
- The \`searchable/\` directory is automatically updated when you run \`thoughts sync\`

## Usage

Create markdown files in these directories to document:
- Architecture decisions
- Design notes
- TODO items
- Investigation results
- Research findings
- Handoff documents

Quick access:
- \`thoughts/${user}/\` for your repo-specific notes (most common)
- \`thoughts/shared/\` for team-shared repo-specific notes
- \`thoughts/global/${user}/\` for your cross-repo notes

## Commands

- \`thoughts sync\` - Sync thoughts to remote and update searchable index
- \`thoughts status\` - Show sync status
- \`thoughts uninit\` - Remove thoughts from this project (keeps content safe)
- \`thoughts config\` - View/edit configuration

## Important

- Never commit the thoughts/ directory to your code repository
- The git pre-commit hook will prevent accidental commits
- Your thoughts will sync automatically when you commit code (via post-commit hook)
EOF
}

# Setup git hooks
setup_git_hooks() {
    local repo_path="$1"

    # Find git hooks directory (handles worktrees)
    local git_common_dir
    git_common_dir=$(git -C "$repo_path" rev-parse --git-common-dir 2>/dev/null) || return 1

    # Make absolute if relative
    if [[ "$git_common_dir" != /* ]]; then
        git_common_dir="$repo_path/$git_common_dir"
    fi

    local hooks_dir="$git_common_dir/hooks"
    mkdir -p "$hooks_dir"

    # Pre-commit hook - prevents committing thoughts/
    local pre_commit="$hooks_dir/pre-commit"
    local pre_commit_content="#!/bin/bash
# Thoughts protection - prevent committing thoughts directory
# Version: $HOOK_VERSION

if git diff --cached --name-only | grep -q \"^thoughts/\"; then
    echo \"Cannot commit thoughts/ to code repository\"
    echo \"The thoughts directory should only exist in your separate thoughts repository.\"
    git reset HEAD -- thoughts/
    exit 1
fi

# Call any existing pre-commit hook
if [ -f \"$pre_commit.old\" ]; then
    \"$pre_commit.old\" \"\$@\"
fi"

    # Post-commit hook - auto-sync thoughts
    local post_commit="$hooks_dir/post-commit"
    local post_commit_content="#!/bin/bash
# Thoughts auto-sync after commits
# Version: $HOOK_VERSION

# Skip in worktrees to avoid confusion
if [ -f .git ]; then
    exit 0
fi

# Get the commit message
COMMIT_MSG=\$(git log -1 --pretty=%B)

# Auto-sync thoughts in background
thoughts sync \"Auto-sync: \$COMMIT_MSG\" >/dev/null 2>&1 &"

    # Helper to check if hook needs updating
    hook_needs_update() {
        local hook_path="$1"
        [ ! -f "$hook_path" ] && return 0

        local content=$(cat "$hook_path")
        [[ "$content" != *"Thoughts"* ]] && return 1  # Not our hook

        local version=$(echo "$content" | grep -o "Version: [0-9]*" | grep -o "[0-9]*")
        [ -z "$version" ] && return 0  # No version, needs update
        [ "$version" -lt "$HOOK_VERSION" ] && return 0
        return 1
    }

    local updated=()

    # Install pre-commit hook
    if hook_needs_update "$pre_commit"; then
        if [ -f "$pre_commit" ]; then
            local content=$(cat "$pre_commit")
            if [[ "$content" != *"Thoughts"* ]]; then
                mv "$pre_commit" "$pre_commit.old"
            else
                rm "$pre_commit"
            fi
        fi
        echo "$pre_commit_content" > "$pre_commit"
        chmod +x "$pre_commit"
        updated+=("pre-commit")
    fi

    # Install post-commit hook
    if hook_needs_update "$post_commit"; then
        if [ -f "$post_commit" ]; then
            local content=$(cat "$post_commit")
            if [[ "$content" != *"Thoughts"* ]]; then
                mv "$post_commit" "$post_commit.old"
            else
                rm "$post_commit"
            fi
        fi
        echo "$post_commit_content" > "$post_commit"
        chmod +x "$post_commit"
        updated+=("post-commit")
    fi

    if [ ${#updated[@]} -gt 0 ]; then
        echo "Updated git hooks: ${updated[*]}"
    fi
}

# Main init logic
main() {
    local project_name="$1"

    # Get config values
    local thoughts_repo=$(get_thoughts_repo)
    local repos_dir=$(get_repos_dir)
    local global_dir=$(get_global_dir)
    local user=$(get_user)
    local current_repo=$(get_current_repo)

    # Determine project name
    if [ -z "$project_name" ]; then
        # Check if already mapped
        project_name=$(get_repo_mapping "$current_repo")
        if [ -z "$project_name" ]; then
            project_name=$(basename "$current_repo")
            project_name=$(sanitize_name "$project_name")
        fi
    else
        project_name=$(sanitize_name "$project_name")
    fi

    echo "Initializing thoughts for: $project_name"
    echo "  User: $user"
    echo "  Thoughts repo: $thoughts_repo"

    # Check if we're in a git repo
    if [ ! -d ".git" ] && [ ! -f ".git" ]; then
        echo "Warning: Not in a git repository root"
    fi

    # Paths in the thoughts repo
    local project_thoughts="$thoughts_repo/$repos_dir/$project_name"
    local global_thoughts="$thoughts_repo/$global_dir"

    # Create directory structure in thoughts repo
    echo "Creating thoughts directory structure..."
    mkdir -p "$project_thoughts/$user"
    mkdir -p "$project_thoughts/shared/handoffs"
    mkdir -p "$project_thoughts/shared/plans"
    mkdir -p "$project_thoughts/shared/research"
    mkdir -p "$global_thoughts/$user"
    mkdir -p "$global_thoughts/shared"

    # Handle existing thoughts directory
    if [ -d "thoughts" ] && [ ! -L "thoughts" ]; then
        echo "Error: thoughts/ directory exists and is not a symlink"
        echo "If you want to migrate existing thoughts, run:"
        echo "  mv thoughts/* $project_thoughts/"
        echo "  rm -rf thoughts"
        echo "Then run this script again."
        exit 1
    fi

    # Remove existing thoughts directory/symlink if present
    if [ -e "thoughts" ] || [ -L "thoughts" ]; then
        echo "Removing existing thoughts setup..."
        # Handle searchable directory permissions
        if [ -d "thoughts/searchable" ]; then
            chmod -R 755 "thoughts/searchable" 2>/dev/null || true
        fi
        rm -rf thoughts
    fi

    # Create thoughts directory with symlinks
    echo "Creating symlinks..."
    mkdir -p thoughts

    # User-specific thoughts for this repo
    ln -s "$project_thoughts/$user" "thoughts/$user"

    # Shared thoughts for this repo
    ln -s "$project_thoughts/shared" "thoughts/shared"

    # Global thoughts (cross-repo)
    ln -s "$global_thoughts" "thoughts/global"

    # Generate CLAUDE.md
    generate_claude_md "$thoughts_repo" "$repos_dir" "$project_name" "$user" > thoughts/CLAUDE.md

    # Setup git hooks
    setup_git_hooks "$current_repo"

    # Add to .gitignore if not already present
    if [ -f ".gitignore" ]; then
        if ! grep -q "^thoughts/$" .gitignore 2>/dev/null; then
            echo "Adding thoughts/ to .gitignore"
            echo "thoughts/" >> .gitignore
        fi
    else
        echo "Creating .gitignore with thoughts/"
        echo "thoughts/" > .gitignore
    fi

    # Save repo mapping
    set_repo_mapping "$current_repo" "$project_name"

    # Pull latest if remote exists
    if git -C "$thoughts_repo" remote get-url origin &>/dev/null; then
        echo "Pulling latest thoughts..."
        git -C "$thoughts_repo" pull --rebase 2>/dev/null || echo "Warning: Could not pull latest"
    fi

    echo ""
    echo "Done! Thoughts initialized with structure:"
    echo "  thoughts/"
    echo "    $user/     -> $project_thoughts/$user/"
    echo "    shared/    -> $project_thoughts/shared/"
    echo "    global/    -> $global_thoughts/"
    echo "    CLAUDE.md  (instructions for AI tools)"
    echo ""
    echo "Protection enabled:"
    echo "  Pre-commit hook: Prevents committing thoughts/"
    echo "  Post-commit hook: Auto-syncs thoughts after commits"
    echo ""
    echo "Next steps:"
    echo "  1. Run 'thoughts sync' to create the searchable index"
    echo "  2. Create markdown files in thoughts/$user/ for your notes"
    echo "  3. Run 'thoughts status' to check sync status"
}

main "$@"
